<!DOCTYPE html>

<html>
<head>
    <title>Biconnected Components - emi-h.com</title>

    <link rel="stylesheet" href="/style.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="UTF-8" />
    <script type="text/javascript">
        function getCookie(name) {
            const value = document.cookie.split('; ').find((x) => x.startsWith(name + '='));
            return value ? value.split('=')[1] : null;
        }
    </script>
</head>

<body class="light-mode">
    <header>
        <div id="header-left">
            <div class="menu-item">
                <a href="/">emi-h.com</a>
            </div>
        </div>
        <div id="header-center">
            <div class="menu-item">
                <a href="/software">Software Projects</a>
            </div>
            <div class="menu-item">
                <a href="/music">Music</a>
            </div>
            <div class="menu-item">
                <a href="/articles">Articles</a>
            </div>
            <div class="menu-item">
                <a href="/resources">Resources</a>
            </div>
            <div class="menu-item">
                <a href="/tools">Tools</a>
            </div>
        </div>
        <div id="header-right">
            <div class="menu-item">
                <a onclick="toggleMode();" style="cursor: pointer;">Toggle theme</a>
            </div>
        </div>
    </header>
    <div id="lower-body">
        <main>
            <h1 id="title"><a href="#title">Biconnected Components</a></h1>

            <p>
                There are many articles online about graphs and (1-)connected components, but not many about biconnected components
                (BCCs), even though these are way more interesting and can be used to solve many problems! Especially in
                competitive programming it is vital to know about this technique.
            </p>

            <p>
                I will outline what biconnected components are, how they work similar to/different from connected components, and
                how to find them algorithmically (with C++ code included). Presumed knowledge is knowing what a graph is. Sections:
            </p>

            <ol>
                <li><a href="#what-is-biconnectedness">What is biconnectedness?</a> (Introduces a running example.)</li>
            </ol>

            <h2 id="biconnectedness-in-a-problem"><a href="#biconnectedness-in-a-problem">Biconnectedness in a Problem</a></h2>

            <p>
                Let's introduce the concept by looking at a problem that BCCs could help solve.
            </p>

            <p>
                Charlotte is a secret agent for Enforcement of Metro Integrity (EMI), and she is tasked with transporting a
                top-secret package from one of her informants, Alice, to an undercover agent, Bob. Alice and Bob must not meet each
                other, because that would ruin the safety of the mission, so they must be at different metro stations, and
                Charlotte can naturally only use the metro network for transport. The matter is further complicated by the fact
                that Eve, Charlotte's adversary, is trying to sabotage the mission by disabling one unknown metro connection! For
                the sets of meeting locations \( A \) where Alice can meet and \( B \) where Bob can meet, how many possible pairs
                \( (a, b) \) are there such that Charlotte can safely transport the package from \( a \) to \( b \) no matter which
                line Eve disables?
            </p>

            <img style="width: min(100%, 30em);" class="light-mode-only" src="/images/algorithms/bcc/light-example-1.svg" />

            <p><em>
                Example metro network 1: nodes in the \( A \) set are marked with an A, nodes in the \( B \) set are marked with a
                B; an example valid pair of locations would be \( (3, 1) \), because no matter which edge Eve chooses to sabogate,
                there is still a path from \( 3 \) to \( 1 \).
            </em></p>

            <p>
                The metro network is a graph \( G \) with \( n \) nodes (metro stations) and \( m \) edges (metro lines).
                \( A \) and \( B \) are then subsets of the set of nodes \( V(G) \). We are trying to find an algorithm with the
                best possible running time. We can use the following definition to make the objective a bit more precise:
            </p>

            <p>
                <strong>Definition:</strong> two nodes \( a, b \) are <em>edge-biconnected</em> if there exist two edge-disjoint
                paths from \( a \) to \( b \), i.e., two paths that do not share any edges.
            </p>

            <p>
                For instance, in the example there are two edge-disjoint paths from node 3 to 1: one that goes from 3 directly to
                1, and one that goes from 3 through 6 to 1. However, there are no two edge-disjoint paths from node 2 to 5: any
                path must go through the same edge \( \{ 4, 8 \} \), so we cannot choose two paths to be fully edge-disjoint.
                Then in this problem we are trying to count the number of pairs \( (a, b) \) with \( a \in A \) and \( b \in B \)
                that are edge-biconnected. After all, if we have such edge-disjoint paths, then even if Eve sabotages an edge on
                one path, we can always still pick the other path.
            </p>

            <p>
                The most naive algorithm would be to consider each \( a \in A \) and \( b \in B \). We would then go over each
                edge, remove it, and check if there is still a path from \( a \) to \( b \) using a simple graph traversal. This
                approach would have a time complexity of \( O(|A| \cdot |B| \cdot m \cdot (n + m)) \), which is very bad.
            </p>

            <p>
                We could try to speed up this approach by precomputing for each edge the connected components (CCs) of the graph
                without that edge, making the path checking constant time. First we would start with the set of all \( (a, b) \)
                pairs, and iteratively remove pairs that we find can be blocked off by Eve's sabotage. Then we would iterate over
                each of the \( m \) edges, and: (1) remove it and compute for each node in which connected component it lies
                (\( O(m + n) \) time using a simple graph traversal), and (2) for each \( (a, b) \) pair, remove it if they do not
                both lie in the same connected component (now a constant time operation, so \( O(|A| \cdot |B|) \) overall). This
                leads to to a complexity of \( O(m \cdot ((n + m) + |A| \cdot |B|)) \), which is definitely an improvement,
                and we considered how to leverage connected components. Click through the animation below to see how this algorithm
                would work (the dashed circles indicate connected components with the edge removed). However, the running time is
                still quite miserable.
            </p>

            <div id="cc-stepper" class="stepper">
                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1.svg" />
                    <p>&nbsp;</p>
                </div>

                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-cc-1.svg" />
                    <p>If Eve sabotages this edge: all nodes can reach all nodes</p>
                </div>

                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-cc-2.svg" />
                    <p>If Eve sabotages this edge: all nodes can reach all nodes</p>
                </div>

                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-cc-3.svg" />
                    <p>If Eve sabotages this edge: remove pairs starting with 2 ending with 1/4/5/8</p>
                </div>

                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-cc-4.svg" />
                    <p>If Eve sabotages this edge: all nodes can reach all nodes</p>
                </div>

                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-cc-5.svg" />
                    <p>If Eve sabotages this edge: all nodes can reach all nodes</p>
                </div>

                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-cc-6.svg" />
                    <p>If Eve sabotages this edge: all nodes can reach all nodes</p>
                </div>

                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-cc-7.svg" />
                    <p>
                        If Eve sabotages this edge: remove pairs starting with 2/3/4 ending with 5/8, and pairs starting with 7/8
                        ending with 1/4
                    </p>
                </div>

                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-cc-8.svg" />
                    <p>If Eve sabotages this edge: all nodes can reach all nodes</p>
                </div>

                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-cc-9.svg" />
                    <p>If Eve sabotages this edge: all nodes can reach all nodes</p>
                </div>

                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-cc-10.svg" />
                    <p>If Eve sabotages this edge: all nodes can reach all nodes</p>
                </div>
            </div>

            <p>
                <button class="stepper-previous" data-target="cc-stepper">previous</button>
                <span class="stepper-counter" data-target="cc-stepper"></span>
                <button class="stepper-next" data-target="cc-stepper">next</button>
            </p>

            <p>
                The final set of pairs is \( \{ (3, 1), (4, 1), ~~ (2, 2), ~~ (7, 5), (7, 8), (8, 5), (8, 8) \} \).
            </p>

            <p>
                In this example, we are definitely doing a lot of unnecessary work, and you might also notice that the final set of
                pairs has a specific pattern to it (whitespace to make this a bit more obvious). First of all, for each pair there
                exist two edge-disjoint paths like discussed from the A node to the B node:
            </p>

            <div id="pairs-stepper" class="stepper">
                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-pairs-3-1.svg" />
                    <p>Pair: \( (3, 1) \)</p>
                </div>

                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-pairs-4-1.svg" />
                    <p>Pair: \( (4, 1) \)</p>
                </div>

                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-pairs-2-2.svg" />
                    <p>Pair: \( (2, 2) \)</p>
                </div>

                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-pairs-7-5.svg" />
                    <p>Pair: \( (7, 5) \)</p>
                </div>

                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-pairs-7-8.svg" />
                    <p>Pair: \( (7, 8) \)</p>
                </div>

                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-pairs-8-5.svg" />
                    <p>Pair: \( (8, 5) \)</p>
                </div>

                <div>
                    <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-pairs-8-8.svg" />
                    <p>Pair: \( (8, 8) \)</p>
                </div>
            </div>

            <p>
                <button class="stepper-previous" data-target="pairs-stepper">previous</button>
                <span class="stepper-counter" data-target="pairs-stepper"></span>
                <button class="stepper-next" data-target="pairs-stepper">next</button>
            </p>

            <p>We can (suggestively) draw the pairs in the graph as follows:</p>

            <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-1-all-pairs.svg" />

            <p>
                Notice that we just have a few clusters of nodes, and within each cluster every possible pair is interconnected (a
                clustering like this is called a <em>partition</em> of the nodes). Can we prove that we can always find such a
                clustering/partition? Or could it be that in some graph, there is an edge-biconnected pair \( x, y \), an
                edge-biconnected pair \( y, z \), but not an edge-biconnected pair \( x, z \)? (Think about counterexamples, or
                convince yourself this should always hold.)
            </p>

            <h2 id="edge-biconnected-components"><a href="#edge-biconnected-components">Edge-Biconnected Components</a></h2>

            <p>
                Okay, I am kind of giving it away by naming this section like this. But it is a very doable exercise to prove that
                such a partition is always possible, where within each cluster all the pairs are connected through a pair of
                edge-disjoint paths, and between two distinct clusters, there are no pairs connected in that way. When thinking
                about partitions, you should always think about the mathematical concept of an <em>equivalence relation</em>. If
                edge-biconnectedness were an equivalence relation, we would need to prove the following three properties:
            </p>

            <ul>
                <li>Reflexive: any node \( u \) is edge-biconnected to itself</li>
                <li>Symmetric: if \( u \) is edge-biconnected to \( v \), then \( v \) must be edge-biconnected to \( u \)</li>
                <li>
                    Transitive: if \( u \) is edge-biconnected to \( v \) and \( v \) is edge-biconnected to \( w \), then \( u \)
                    must be edge-biconnected to \( w \)
                </li>
            </ul>

            <p>
                It turns out that edge-biconnectedness is in fact an equivalence relation, and the proofs for these properties are
                definitely doable to do for yourself. This gives us a new algorithm for our problem. First compute the
                edge-biconnected components for the entire graph. Then within each component count how many \( A \) nodes and how
                many \( B \) nodes there are. Because within a component each pair of nodes is edge-biconnected, we can simply
                multiply the A count by the B count and add this value to the result. Between any two different components there
                are no edge-biconnected pairs, we are not missing any pairs.
            </p>

            <p>
                Now all we need is an algorithm for computing edge-biconnected components!
            </p>

            <h2 id="edge-biconnected-component-algorithm"><a href="#edge-biconnected-component-algorithm">Edge-Biconnected Component Algorithm</a></h2>

            TODO

            <h2 id="vertex-biconnected-components"><a href="vertex-biconnected-components">Vertex-Biconnected Components</a></h2>

            <p>
                We can repeat the problem that we stated before but change one thing: what if after you picking a station for Alice
                and one for Bob, Eve sabotages a metro station instead of a metro line? (She would not be able to sabotage the
                metro station that Alice or Bob was in.) Do we still have an equivalence relation on the nodes like with
                edge-biconnectedness? I will not discuss it in this article, but consider the following example and think about if
                the transitivity property holds for vertex-biconnectedness:
            </p>

            <img class="light-mode-only" style="width: min(100%, 30em);" src="/images/algorithms/bcc/light-example-2.svg" />

            <p>
                I will also leave you with a hint: a node can be part of multiple vertex-biconnected components. Consider instead
                an equivalence relation on the edges (it's a cute little symmetry that edge-biconnectedness induces an equivalence
                relation on the vertices, and vertex-biconnectedness induces an equivalence relation on the edges).
            </p>

            <h2 id="terminology-index"><a href="#terminology-index">Terminology Index</a></h2>

            <p>
                Here is a list of terminology:
            </p>

            <ul>
                <li>
                    <em>Edge-biconnectedness</em> (for pairs of nodes): a node \( u \) is edge-biconnected to a node \( v \) if
                    there exist two edge-disjoint paths from \( u \) to \( v \).
                </li>
                <li>
                    <em>Edge-biconnectedness</em> (for whole undirected graphs): a graph is edge-biconnected if the graph is
                    connected even if any one edge is removed.
                </li>
                <li>
                    <em>Edge-biconnected components</em>: a subset of nodes forms an edge-biconnected component if each pair of
                    nodes within it is edge-biconnected, and it cannot have any additional nodes added to it and still have this
                    property. (The edge-biconnected components of any graph are the equivalence classes of the edge-biconnectedness
                    equivalence relation.)
                </li>
                <li>
                    <em>Bridge</em>: an edge is a bridge if, when removed, the number of connected components is increased (in the
                    example graph there are two such edges, which you can see by stepping through the second figure).
                </li>
                <li>
                    <em>Vertex-biconnectedness</em> (for pairs of nodes): a node \( u \) is vertex-biconnected to a node \( v \) if
                    there exist two vertex-disjoint paths from \( u \) to \( v \), or \( u = v \). (Note that this is not an
                    equivalence relation.)
                </li>
                <li>
                    <em>Vertex-biconnectedness</em> (for whole undirected graphs): a graph is vertex-biconnected if the graph is
                    connected even if any one node is removed.
                </li>
                <li>
                    <em>Vertex-biconnected component</em>: a subset of nodes forms a vertex-biconnected component if each pair of
                    nodes within it is vertex-biconnected, and it cannot have any additional nodes added to it and still have this
                    property. (Note that the vertex-biconnected components of a graph are not necessarily a partition of the
                    nodes.)
                </li>
                <li>
                    <em>Articulation point</em>: a node is an articulation point if it is part of more than one vertex-biconnected
                    components.
                </li>
            </ul>

        </main>
        <footer>
            <div class="footer-table-wrapper"><table id="footer-table"><tbody>
                <tr>
                    <td><a href="mailto:emilia144@proton.me">emilia144@proton.me</a></td>
                    <td><a href="https://github.com/emilia-h">github</a></td>
                </tr>
                <tr>
                    <td><a href="/about">about</a></td>
                    <td><a href="https://github.com/emilia-h/emilia-h.github.io">site repo</a></td>
                </tr>
            </tbody></table></div>
        </footer>
    </div>

    <script type="text/javascript">
        let theme = 'light-mode';

        function toggleMode() {
            document.body.classList.remove(theme);
            if (theme == 'dark-mode') {
                theme = 'light-mode';
            } else if (theme == 'light-mode') {
                theme = 'dark-mode';
            }
            document.body.classList.add(theme);
            document.cookie = `pref=${theme}; samesite=strict; path=/`;
        }

        const previousSetting = getCookie('pref');
        if ((previousSetting && previousSetting !== theme) ||
            (!previousSetting && window.matchMedia &&
            window.matchMedia('(prefers-color-scheme: dark)').matches)
        ) {
            toggleMode();
        }
    </script>
    <script src="/scripts/elements.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
</body>
</html>